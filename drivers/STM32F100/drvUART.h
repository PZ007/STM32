/**
 *  Filename:       drvUART.h
 *  Platform(s):    STM32F10x
 *  Project:
 *  Created:        Apr 25, 2013
 *  Description:    Universal Asynchronous Receiver Transmitter driver module
 *                  using the interrupt mechanism for reading data from and
 *                  writing data to memory.
 *
 *                  This module has the following responsibilities:
 *                  - Define an API for using the three internal USARTs.
 *                  - Implement a simple UART interface.
 *
 *                  The STM32F1xx low and medium-density devices have got
 *                  three internal USARTs. The high-density devices have got
 *                  two additional UARTs. This module implements a multi-
 *                  instance driver for the three USARTs.
 *                  The transmit and receive buffers are defined and allocated
 *                  externally, allowing the sizes to be chosen as needed.
 *
 *                  Every received or transmitted byte respectively triggers
 *                  a receive or transmit interrupt.
 *
 *                  Behavior of this driver when the receive buffer is full:
 *                  If the receive buffer is full but data is yet arriving,
 *                  the arriving data will be discarded. If an error handler
 *                  function has been registered, it will be called once for
 *                  every discarded byte.
 *
 *                  Character size:
 *                  - The character size is 8bit.
 *                  - 7 or 9 bit characters aren't supported.
 *
 *                  Baud rates:
 *                  - The minimum baud rate is defined by the USART's peripheral
 *                    clock frequency. This clock comes from the RCC SoC module.
 *                    The theoretically lowest possible baud rate is 366bit/s
 *                    with a peripheral clock frequency of 24MHz.
 *                    Lower baud rates are possible if the peripheral clock is
 *                    lowered. This however would also lower the highest
 *                    possible baud rate.
 *                  - The maximum baud rate is also defined by the peripheral
 *                    clock frequency. The theoretical limit is 1500kbit/s.
 *                    The practical limit is between 300kbit/s and 400kbit/s
 *                    however, as external loopback tests between 2 USARTs
 *                    have shown. At higher baud rates, bytes start getting
 *                    lost.
 *
 *                  Parity:
 *                  - Default is <em>no parity</em>.
 *                  - Even and odd parity bits are supported. The parity type
 *                    can be selected at the start of the driver instance.
 *                  - The parity bit is the 9th bit (MSB) in the character and
 *                    automatically generated by the UART before transmission
 *                    and checked by the UART after reception. If an error
 *                    handler function has been registered, it will be called
 *                    once for every received character with a parity error.
 *                  - Characters with parity errors are still returned when
 *                    the \c _read() function is called.
 *
 *  Notes:          - USART stands for <em> Universal Synchron and Asynchron
 *                    Receiver Transmitter </em>.
 *                  - Alternate function pin remapping is currently not
 *                    supported.
 *
 *  Author:         Andreas Isenegger
 *  Copyright:      2013-2014, Bitcontrol GmbH, Switzerland.
 *                  Copyright granted under the MIT License.
 *                  See http://opensource.org/licenses/MIT for the license text.
 */

#ifndef DRVUART_H_
#define DRVUART_H_

#include <cfgGlobal.h>

#ifdef __cplusplus
extern "C" {
#endif

//------------------------------------------------------------------------------
// Symbols and Macros
/** Maximum baud rate in [bit/s]. */
#define DRV_UART_BAUDRATE_MAX           250000

/** Minimum baud rate in [bit/s]. */
#define DRV_UART_BAUDRATE_MIN           400

/** UART overrun error. */
#define DRV_UART_ORE                    0x01

/** UART parity error. */
#define DRV_UART_PE                     0x02

/** Driver's receive buffer full error. */
#define DRV_UART_RBF                    0x04

//------------------------------------------------------------------------------
// Types
/** Pointer to error handler function. */
typedef void (*drvUART_errHandler_f)(int arg);

/** Serial attribute configuration structure. */
typedef struct drvUART_serialAttr_struct
{
    int baudrate; /**< Baudrate in bit/s. */
    char parity; /**< Parity bit. 0: none, 1: odd, 2: even. */
    char stopBits; /**< Number of stop bits. 1: 1 stop bit, 2: 2 stop bits. */
} drvUART_serialAttr_t;

/** UART driver module configuration structure. */
typedef struct drvUART_cfg_struct
{
    /* SoC configuration. */
    /** Receiver's bit number on the dedicated GPIO port. */
    unsigned short GPIO_portBitNumberRx;

    /** Transmitter's bit number on the dedicated GPIO port. */
    unsigned short GPIO_portBitNumberTx;

    /** USART's instance identifier of its related GPIO driver. */
    int instIdGPIO;

    /** Interrupt channel number. */
    unsigned char NVIC_IRQ_channel;

    /** Interrupt group priority. */
    unsigned char NVIC_IRQ_groupPriority;

    /** Interrupt's sub-priority in group. */
    unsigned char NVIC_IRQ_subPriority;

    /** Bit mask to enable the clock to the USART. */
    unsigned int RCC_clockEnableBitMask;

    /** Dedicated RCC APBx peripheral clock enable register. */
    volatile unsigned int* RCC_clockEnableRegister;

    /** Pointer to the CMSIS USART structure. */
    USART_TypeDef* USARTx;

    /* RX and TX buffers. */
    /** Pointer to the receive buffer that shall be used internally. */
    char* rxBuffer;

    /** Size of the receive buffer in bytes. */
    short rxBufferSize;

    /** Pointer to the transmit buffer that shall be used internally. */
    char* txBuffer;

    /** Size of the transmit buffer in bytes. */
    short txBufferSize;
} drvUART_cfg_t;

//------------------------------------------------------------------------------
// Constants and Variables

//------------------------------------------------------------------------------
// Functions
/**
 * Starts an instance of this module.
 * Starting an instance twice without stopping it in between returns an error.
 * @param[in] instId is the instance identifier.
 * @param[in] attr points to the structure that contains the serial interface
 * attributes.
 * @return \c R_SUCCESS if the driver instance could be started with the
 * selected serial interface attributes, \c R_ERROR otherwise.
 */
int drvUART_start(int instId, const drvUART_serialAttr_t* attr);

/**
 * Stops an instance of this module.
 * Stopping an instance twice without starting it in between returns no error.
 * @param[in] instId is the instance identifier.
 * @return \c R_SUCCESS if the parameter checks pass, \c R_ERROR otherwise.
 */
int drvUART_stop(int instId);

/**
 * Queries the driver instance if the UART's transmitter is idle or not.
 * It is considered idle if the driver's transmit buffer, the UART's transmit
 * buffer and the UART's transmit shift register are empty and the stop bit(s)
 * of the last byte have been sent.
 * @param[in] instId is the instance identifier.
 * @param[out] *result is \c TRUE if the transmitter of the UART is idle,
 * \c FALSE otherwise.
 * @return \c R_SUCCESS if the parameter checks pass, \c R_ERROR otherwise.
 */
int drvUART_isTxIdle(int instId, BOOL* result);

/**
 * Reads data from the driver instance.
 * This function reads up to \c bufSize bytes from the receive buffer of the
 * driver. It returns immediately, even if there are no data in the receive
 * buffer.
 * @param[in] instId is the instance identifier.
 * @param[out] dstBuf points to the destination buffer that will hold the data
 * after this function has returned successfully. In case of an error it won't
 * be changed.
 * @param[in] bufSize specifies the size of the passed destination buffer in
 * bytes.
 * @return the number of bytes read, or \c R_ERROR if an error occurred.
 */
int drvUART_read(int instId, char* dstBuf, int bufSize);

/**
 * Registers an error handler function to the driver instance.
 * This function is also used to deregister an error handler: if the parameter
 * \c errHandler is \c NULL, the call to the error handling function is
 * disabled.
 * @param[in] instId is the instance identifier.
 * @param[in] errHandler points to the error handler function that is called
 * whenever this driver instance encounters an error. Covered are framing,
 * break, parity and overrun errors. The passed error handler is executed in
 * interrupt context. If it is \c NULL, no error handler will be called.
 * @return \c R_SUCCESS if the parameter checks pass, \c R_ERROR otherwise.
 */
int drvUART_registerErrorHandler(int instId, drvUART_errHandler_f errHandler);

/**
 * Writes data to the driver instance.
 * This function writes \c dataSize bytes to the send buffer of the driver. It
 * returns immediately, even if the send buffer couldn't take all data.
 * @param[in] instId is the instance identifier.
 * @param[in] srcBuf is the source buffer that contains the data that shall be
 * written to the UART.
 * @param[in] dataSize is the number of bytes in the source buffer that should
 * be written to the UART.
 * @return the number of bytes written, or \c R_ERROR if an error occurred.
 */
int drvUART_write(int instId, const char* srcBuf, int dataSize);

#ifdef __cplusplus
}
#endif

#endif /* DRVUART_H_ */
